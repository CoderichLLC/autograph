TODO:
  * Pipeline
    - arguments?
    - path, validation?
  * 'setup' SystemEvent
  * GraphQL API (or is that another module?)
  * Magic methods? $lookup?
  * I don't like resolver.auto(); can it be done in the GraphQL API layer?
  * Why do you send `${model}` in query instead of the actual model object?

Known Issues:
  * MongoClient - not all queries go through $aggregateQuery and so you lose things like $project the result
  * query.flags.debug should not be at driver level
  * You only need to $addFields for mongo regex when it's not already a String (eg. Boolean)

Improvement Considerations:
  * Upsert???
  * EventEmitter
    - Debounce a function (debounce) to prevent excessive/redundant calls?
    - Memoize a function to prevent excessive/redundant calls?
    - changeset?
  * Allow user-defined loaders (replacing .named?)
  * If no change in data, prevent entire operation?
  * Need to consider if mutationMany really needs to be spread into individual mutationOnes
    - Validation performed on each doc post mutation
    - Audit trail per record
    - Inherit address currently implemented as cascade logic
    - onDelete
  * config.dataSources to determine if supports
    - Joins
    - Transactions
    - Batches
    - Referential Integrity (no need to ensureId)
    - Composite index keys (probably need to move these tests elsewhere)
  * onDelete defer - could probably be done dynamically instead
  * DataLoader - rewrite for batch queries
  * EnsureId - inline query?
  * Do you need "doc" hydrated or could it be lazy-loaded on demand?

BREAKING CHANGELOG:
  * Revamped how transactions work
  * Revamped how initial setup works (config.js)
  * Revamped Pipeline
    - Pipeline "toId" is now $id or $pk depending upon needs
    - Removed deserialize + transform ==> normalize
        instruct
        normalize
        construct
        restruct
        destruct
        serialize
        validate
  * Revamped Emitter
    - "Basic" functions are hoisted to the top for execution; RETURNING a value will bypass thunk()
    - "Next" functions are run next, next() must ALWAYS be called; passing a value to next() will bypass thunk()
    - Event arguments refactored (no more merged! use query.input):
      {
        schema,
        context,
        resolver,
        query { args, id, model, crud, key, doc, input, sort, result }, // Transformed values
      }
  * QueryBuilder.resolve() is now .auto()

---------

* select('author.*') // populate/hydrate (left join)
* where('author.name') // join
* Things like "ensureId" are driver-specific? (eg. A SQL driver would have a FK relationship defined)

---------

[
  'defaultValue', // Assign default value when undefined
  'castValue', // Cast value to schema defined type
  '$normalize', // Normalized value
  '$instruct', // Instruct value (will define attribute even if undefined)
  ...crudLines, // CRUD specific transformations
  '$serialize', // input + where transformations to db driver
  '$validate', // validation
]
