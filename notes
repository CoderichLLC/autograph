TODO:
  * Emitter: Allow the modification of query|response, prevent operation, short-circuit with new response, business logic side-effects
    - [
      'setup',
      'query|mutation',
      'validate',
      'response' ???
    ]
    - event should have getters to interesting data
    {
      context,
      resolver,
      query,
      args,
      doc?, // Document from the db or query.input
      merged?, // merge(doc, query.input)
      result?, // The result...
      changeset?,
    }
  * Pipeline
    - arguments?
    - path, validation?
  * GraphQL API (or is that another module?)
  * Transactions enabled via config

Known Issues:
  * MongoClient - not all queries go through $aggregateQuery and so you lose things like $project the result
  * query.flags.debug should not be at driver level
  * You only need to $addFields for mongo regex when it's not already a String (eg. Boolean)
  * Tests unable to run because of mongo memory server setup

Improvement Considerations:
  * Upsert???
  * Why do you send `${model}` in query instead of the actual model object?
  * If no change in data, prevent entire operation?
  * Consider passing input to driver without merging doc (a lot of transformations happen) and then combining result in QueryResolver
  * Need to consider if mutationMany really needs to be spread into individual mutationOnes
    - Validation performed on each doc post mutation
    - Audit trail per record
    - Inherit address currently implemented as cascade logic
    - onDelete
  * config.dataSources to determine if supports
    - Joins
    - Transactions
    - Batches
    - Composite index keys (probably need to move these tests elsewhere)
  * onDelete defer - could probably be done dynamically instead
  * DataLoader - rewrite for batch queries
  * EnsureId - inline query?

BREAKING CHANGELOG:
  * Revamped how transactions work
  * Revamped how initial setup works (config.js)
  * Revamped Pipeline
    - Pipeline "toId" is now $id or $pk depending upon needs
    - Removed deserialize + transform ==> normalize
    - Merlin "transform: toArray" needed?
  * QueryBuilder.resolve() is now .auto()

---------

* select('author.*') // populate/hydrate (left join)
* where('author.name') // join
* Things like "ensureId" are driver-specific? (eg. A SQL driver would have a FK relationship defined)

---------

// Rename key
// const $key = Object.entries(this.#model.keyMap || {}).reduce((p, [k, v]) => {
//   const regex = new RegExp(`((?:^|\\.))${k}\\b`, 'g');
//   return p.replace(regex, `$1${v}`);
// }, key);

// // Special array handling, ensure we understand the meaning
// if (Array.isArray(value)) {
//   const match = $key.match(/\$[a-zA-Z]{2}(?=']|$)/);
//   const $value = value.map(el => this.#normalize(el));
//   value = match ? $value : { [this.#arrayOp]: $value };
// }

findOne: [select, where]
findMany: [select, where]
count: [select, where]
updateOne: [select, where, input]
updateMany: [select, where, input]
upsertOne: [select, where, input]
upsertMany: [select, where, input]
deleteOne: [select, where]
deleteMany: [select, where]
